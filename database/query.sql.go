// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const addProductToInvoice = `-- name: AddProductToInvoice :one
INSERT INTO invoice_item (invoice_id, product_id, count)
VALUES ($1::int, $2::int, $3::int)
ON CONFLICT (invoice_id, product_id)
DO UPDATE SET
    count = EXCLUDED.count
RETURNING id, invoice_id, product_id, count, created_at, updated_at
`

type AddProductToInvoiceParams struct {
	InvoiceID int32
	ProductID int32
	Count     int32
}

func (q *Queries) AddProductToInvoice(ctx context.Context, arg AddProductToInvoiceParams) (InvoiceItem, error) {
	row := q.db.QueryRowContext(ctx, addProductToInvoice, arg.InvoiceID, arg.ProductID, arg.Count)
	var i InvoiceItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.ProductID,
		&i.Count,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customer (first_name, last_name)
VALUES ($1, $2)
RETURNING id, first_name, last_name, created_at, updated_at
`

type CreateCustomerParams struct {
	FirstName string
	LastName  string
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, createCustomer, arg.FirstName, arg.LastName)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO invoice (invoice_number, invoice_date, customer_id)
VALUES ($1::text, $2::timestamp, $3::int)
RETURNING id, invoice_number, invoice_date, customer_id, created_at, updated_at
`

type CreateInvoiceParams struct {
	InvoiceNumber string
	InvoiceDate   time.Time
	CustomerID    int32
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRowContext(ctx, createInvoice, arg.InvoiceNumber, arg.InvoiceDate, arg.CustomerID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.InvoiceDate,
		&i.CustomerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO product (name, description, price, available_items)
VALUES ($1, $2, $3, $4)
RETURNING id, name, description, price, available_items, created_at, updated_at
`

type CreateProductParams struct {
	Name           string
	Description    sql.NullString
	Price          string
	AvailableItems int32
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.AvailableItems,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.AvailableItems,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCustomer = `-- name: DeleteCustomer :one
WITH check_customer AS (
    SELECT EXISTS(SELECT 1 FROM customer WHERE id = $1::int) AS customer_exists
),
delete_customer AS (
    DELETE FROM customer
    WHERE id = $1::int
    RETURNING id, first_name, last_name, created_at, updated_at
)
SELECT
    CASE
        WHEN NOT (SELECT customer_exists FROM check_customer) THEN 'customer_not_found'
        WHEN NOT EXISTS (SELECT 1 FROM delete_customer) THEN 'delete_failed'
        ELSE 'success'
    END AS result
FROM delete_customer
RIGHT JOIN (SELECT NULL) AS dummy ON true
`

func (q *Queries) DeleteCustomer(ctx context.Context, customerID int32) (string, error) {
	row := q.db.QueryRowContext(ctx, deleteCustomer, customerID)
	var result string
	err := row.Scan(&result)
	return result, err
}

const deleteInvoice = `-- name: DeleteInvoice :one
WITH check_invoice AS (
    SELECT EXISTS(SELECT 1 FROM invoice WHERE id = $1::int) AS invoice_exists
),
delete_invoice AS (
    DELETE FROM invoice
    WHERE id = $1::int
    RETURNING id, invoice_number, invoice_date, customer_id, created_at, updated_at
)
SELECT
    CASE
        WHEN NOT (SELECT invoice_exists FROM check_invoice) THEN 'invoice_not_found'
        WHEN NOT EXISTS (SELECT 1 FROM delete_invoice) THEN 'delete_failed'
        ELSE 'success'
    END AS result
FROM delete_invoice
RIGHT JOIN (SELECT NULL) AS dummy ON true
`

func (q *Queries) DeleteInvoice(ctx context.Context, invoiceID int32) (string, error) {
	row := q.db.QueryRowContext(ctx, deleteInvoice, invoiceID)
	var result string
	err := row.Scan(&result)
	return result, err
}

const deleteProduct = `-- name: DeleteProduct :one
WITH check_product AS (
    SELECT EXISTS(SELECT 1 FROM product WHERE id = $1::int) AS product_exists
),
delete_product AS (
    DELETE FROM product
    WHERE id = $1::int
    RETURNING id, name, description, price, available_items, created_at, updated_at
)
SELECT
    CASE
        WHEN NOT (SELECT product_exists FROM check_product) THEN 'product_not_found'
        WHEN NOT EXISTS (SELECT 1 FROM delete_product) THEN 'delete_failed'
        ELSE 'success'
    END AS result
FROM delete_product
RIGHT JOIN (SELECT NULL) AS dummy ON true
`

func (q *Queries) DeleteProduct(ctx context.Context, productID int32) (string, error) {
	row := q.db.QueryRowContext(ctx, deleteProduct, productID)
	var result string
	err := row.Scan(&result)
	return result, err
}

const deleteProductFromInvoice = `-- name: DeleteProductFromInvoice :one
WITH
    check_invoice_item AS (
        SELECT EXISTS(
            SELECT 1 FROM invoice_item
            WHERE invoice_id = $1::int AND product_id = $2::int
        ) AS invoice_item_exists
    ),
    delete_invoice_item AS (
        DELETE FROM invoice_item
        WHERE invoice_id = $1::int AND product_id = $2::int
        RETURNING id, invoice_id, product_id, count, created_at, updated_at
    )
SELECT
    CASE
        WHEN NOT (SELECT invoice_item_exists FROM check_invoice_item) THEN 'invoice_item_not_found'
        WHEN NOT EXISTS (SELECT 1 FROM delete_invoice_item) THEN 'delete_failed'
        ELSE 'success'
    END AS result
FROM delete_invoice_item
RIGHT JOIN (SELECT NULL) AS dummy ON true
`

type DeleteProductFromInvoiceParams struct {
	InvoiceID int32
	ProductID int32
}

func (q *Queries) DeleteProductFromInvoice(ctx context.Context, arg DeleteProductFromInvoiceParams) (string, error) {
	row := q.db.QueryRowContext(ctx, deleteProductFromInvoice, arg.InvoiceID, arg.ProductID)
	var result string
	err := row.Scan(&result)
	return result, err
}

const getCustomer = `-- name: GetCustomer :one
SELECT id, first_name, last_name, created_at, updated_at FROM customer WHERE id = $1
`

func (q *Queries) GetCustomer(ctx context.Context, id int32) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomer, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInvoice = `-- name: GetInvoice :one
SELECT id, invoice_number, invoice_date, customer_id, created_at, updated_at FROM invoice WHERE id = $1
`

func (q *Queries) GetInvoice(ctx context.Context, id int32) (Invoice, error) {
	row := q.db.QueryRowContext(ctx, getInvoice, id)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.InvoiceDate,
		&i.CustomerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT id, name, description, price, available_items, created_at, updated_at FROM product WHERE id = $1
`

func (q *Queries) GetProduct(ctx context.Context, id int32) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.AvailableItems,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCustomers = `-- name: ListCustomers :many

SELECT id, first_name, last_name, created_at, updated_at FROM customer ORDER BY id LIMIT 100
`

// ----------------------------------------------------------------------------------------------------------------------
// customer
// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) ListCustomers(ctx context.Context) ([]Customer, error) {
	rows, err := q.db.QueryContext(ctx, listCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoices = `-- name: ListInvoices :many

SELECT id, invoice_number, invoice_date, customer_id, created_at, updated_at FROM invoice ORDER BY id LIMIT 100
`

// ----------------------------------------------------------------------------------------------------------------------
// invoice
// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) ListInvoices(ctx context.Context) ([]Invoice, error) {
	rows, err := q.db.QueryContext(ctx, listInvoices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.InvoiceDate,
			&i.CustomerID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many

SELECT id, name, description, price, available_items, created_at, updated_at FROM product ORDER BY id LIMIT 100
`

// ----------------------------------------------------------------------------------------------------------------------
// product
// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) ListProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, listProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.AvailableItems,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsFromInvoice = `-- name: ListProductsFromInvoice :many

SELECT
    p.id,
    p.name,
    p.description,
    p.price,
    ii.count,
    CAST((p.price * ii.count) AS numeric(10,2)) AS sum
FROM
    invoice_item ii
    JOIN Product p ON ii.product_id = p.id
WHERE
    ii.invoice_id = $1
ORDER BY
    p.id
 LIMIT
    100
`

type ListProductsFromInvoiceRow struct {
	ID          int32
	Name        string
	Description sql.NullString
	Price       string
	Count       int32
	Sum         string
}

// ----------------------------------------------------------------------------------------------------------------------
// invoice_item
// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) ListProductsFromInvoice(ctx context.Context, invoiceID int32) ([]ListProductsFromInvoiceRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsFromInvoice, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsFromInvoiceRow
	for rows.Next() {
		var i ListProductsFromInvoiceRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Count,
			&i.Sum,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE customer
SET
    first_name = $2,
    last_name = $3
WHERE id = $1
RETURNING id, first_name, last_name, created_at, updated_at
`

type UpdateCustomerParams struct {
	ID        int32
	FirstName string
	LastName  string
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, updateCustomer, arg.ID, arg.FirstName, arg.LastName)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateInvoice = `-- name: UpdateInvoice :one
WITH
    check_invoice AS (
        SELECT EXISTS(SELECT 1 FROM invoice i WHERE i.id = $1) AS invoice_exists
    ),
    update_invoice AS (
        UPDATE invoice
        SET
            invoice_number = $2::text,
            invoice_date = $3::timestamp,
            customer_id = $4::int
        WHERE id = $1
        RETURNING id, invoice_number, invoice_date, customer_id, created_at, updated_at
    )
SELECT
    CASE
        WHEN NOT (SELECT invoice_exists FROM check_invoice) THEN 'invoice_not_found'
        WHEN NOT EXISTS (SELECT 1 FROM update_invoice) THEN 'update_failed'
        ELSE 'success'
    END AS result,
    update_invoice.id, update_invoice.invoice_number, update_invoice.invoice_date, update_invoice.customer_id, update_invoice.created_at, update_invoice.updated_at
FROM update_invoice
RIGHT JOIN (SELECT NULL) AS dummy ON true
`

type UpdateInvoiceParams struct {
	ID            int32
	InvoiceNumber string
	InvoiceDate   time.Time
	CustomerID    int32
}

type UpdateInvoiceRow struct {
	Result        string
	ID            sql.NullInt32
	InvoiceNumber sql.NullString
	InvoiceDate   sql.NullTime
	CustomerID    sql.NullInt32
	CreatedAt     sql.NullTime
	UpdatedAt     sql.NullTime
}

func (q *Queries) UpdateInvoice(ctx context.Context, arg UpdateInvoiceParams) (UpdateInvoiceRow, error) {
	row := q.db.QueryRowContext(ctx, updateInvoice,
		arg.ID,
		arg.InvoiceNumber,
		arg.InvoiceDate,
		arg.CustomerID,
	)
	var i UpdateInvoiceRow
	err := row.Scan(
		&i.Result,
		&i.ID,
		&i.InvoiceNumber,
		&i.InvoiceDate,
		&i.CustomerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE product
SET
    name = $2,
    description = $3,
    price = $4,
    available_items = $5
WHERE id = $1
RETURNING id, name, description, price, available_items, created_at, updated_at
`

type UpdateProductParams struct {
	ID             int32
	Name           string
	Description    sql.NullString
	Price          string
	AvailableItems int32
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.AvailableItems,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.AvailableItems,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
